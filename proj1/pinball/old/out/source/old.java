/* autogenerated by Processing revision 1293 on 2023-09-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class old extends PApplet {



// ball information
// Vec2 ball_pos[] = new Vec2[numBalls];
// Vec2 ball_vel[] = new Vec2[numBalls];
// float ball_radius = new float[numBalls];
// float ball_mass = new float[numBalls];



public void setup() {
    /* size commented out by preprocessor */;
    resetSimulation();
}

public void draw() {
    float dt = 1.0f / frameRate;
    background(255);  // Clear the background
    update(dt);
    // println(frameRate);
}

public void update(float dt) {
  for (int i = 0; i < numBalls; i++) {
    balls[i].update(dt);
    balls[i].wallCollision();
    for (int j = i + 1; j < numBalls; j++) {
        if (balls[i].collidesWith(balls[j])) {
            println("collision");
            balls[i].collided = true; 
            balls[j].collided = true;
            balls[i].resolveCollision(balls[j]);
        } 
    }
  }
  for (int i = 0; i < numBalls; i++) {
    balls[i].render();
    balls[i].collided = false;
  }
}

public void keyPressed() {
    if (key == 'r' || key == 'R') {
        resetSimulation();
    }
}


public void resetSimulation() {
    // reseting all the positions and attributes of the balls
    for (int i = 0; i < numBalls; i++) {
        Vec2 pos = new Vec2(random(width), random(height));
        Vec2 vel = new Vec2(random(-500, 500), random(-500, 500));
        // float radius = random(5, 40);
        float radius = 60;
        float mass = radius * radius; // mass is proportional to area
        balls[i] = new Circle(pos, vel, radius, mass);
    }
}

// checks collisions between circles 
// x1, y1, r1 are the coordinates and radius of the first circle
// x2, y2, r2 are the coordinates and radius of the second circle
public boolean collidesWith (float x1, float y1, float r1, float x2, float y2, float r2) {
    float dx = x1 - x2;
    float dy = y1 - y2;
    float distance = sqrt(dx*dx + dy*dy);
    return distance < r1 + r2;
}

// resolves collisions between two balls 
// void resolveCollision() {
//     // calculate the distance between the two balls
//     float dx = ball1.x - ball2.x;
//     float dy = ball1.y - ball2.y;
//     float distance = sqrt(dx*dx + dy*dy);

//     // calculate the normal vector
//     float nx = dx / distance;
//     float ny = dy / distance;

//     // calculate the tangent vector
//     float tx = -ny;
//     float ty = nx;

//     // project the velocities onto the normal and tangent vectors
//     float dpTan1 = ball1.vx * tx + ball1.vy * ty;
//     float dpTan2 = ball2.vx * tx + ball2.vy * ty;

//     float dpNorm1 = ball1.vx * nx + ball1.vy * ny;
//     float dpNorm2 = ball2.vx * nx + ball2.vy * ny;

//     // calculate the mass of each ball
//     float m1 = (ball1.radius - ball2.radius) / (ball1.radius + ball2.radius);
//     float m2 = (ball2.radius - ball1.radius) / (ball1.radius + ball2.radius);

//     // calculate the new velocity vectors
//     ball1.vx = (dpNorm1 * nx + dpTan1 * tx) * m1;
//     ball1.vy = (dpNorm1 * ny + dpTan1 * ty) * m1;
//     ball2.vx = (dpNorm2 * nx + dpTan2 * tx) * m2;
//     ball2.vy = (dpNorm2 * ny + dpTan2 * ty) * m2;
// }

int numBalls = 10;

Circle[] balls = new Circle[numBalls];
class Circle {
    Vec2 pos;
    Vec2 acc;
    Vec2 vel;
    float x, y, r, mass; 
    boolean collided; 
    boolean infiniteMass;
    float cor = 0.95f; // coefficient of restitution
    
    Circle(Vec2 pos, Vec2 vel, float r , float mass) {
        this.pos = pos;
        this.x = pos.x;
        this.y = pos.y;
        this.r = r;
        this.mass = PI * r * r;
        this.infiniteMass = false;
        this.vel = vel;
        // this.vel = new Vec2(0, 0); // start at reset
        this.acc = new Vec2(0, 300);
        
        this.collided = false;
    }
    public void update(float dt) {
        this.vel.add(this.acc.times(dt));
        this.pos.add(this.vel.times(dt));
        this.x = this.pos.x;
        this.y = this.pos.y;
        
        
    }
    public void render() {
        push(); // Save the current drawing state
        noStroke();
        // Draw the shape centered at the new origin
        if (this.collided == false) {
            fill(42);
        }
        else {
            fill(255, 0, 0);
        }
        ellipse(this.x, this.y, this.r * 2, this.r * 2);
        pop(); // Restore the saved drawing state
    }
    public boolean collidesWith(Circle other) {
        // Check if the distance between the two circles is less than the sum of their radii
        float dx = this.x - other.x;
        float dy = this.y - other.y;
        float distance = sqrt(dx * dx + dy * dy);
        
        return distance < this.r + other.r;
    }
    public void resolveCollision(Circle other) {
        Vec2 delta = this.pos.minus(other.pos);
        float dist = delta.length();
        float overlap = 0.5f * (dist - this.r - other.r);
       // Separate circles, move them away from each other
        this.pos.subtract(delta.normalized().times(overlap));
        other.pos.add(delta.normalized().times(overlap));

        // Collision 
        Vec2 dir = delta.normalized();
        float v1 = dot(this.vel, dir);
        float v2 = dot(other.vel, dir);
        float m1 = this.mass;
        float m2 = other.mass;

        float new_v1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * cor) / (m1 + m2);
        float new_v2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * cor) / (m1 + m2);

        this.vel = this.vel.plus(dir.times(new_v1 - v1));
        other.vel = other.vel.plus(dir.times(new_v2 - v2));
        println("Resolving collision");
    }
    public void wallCollision() {
        // Check for collisions with canvas boundaries
        if (this.x - this.r < 0) {
            this.x = this.r * 1.01f;
            this.vel.x *= -1; // Reverse the x-velocity
        }
        if (this.x + this.r > width) {
            this.x = width - this.r * 1.01f;
            this.vel.x *= -1; // Reverse the x-velocity
        }
        if (this.y - this.r < 0) {
            // Collision with top or bottom wall
            this.y = this.r * 1.01f;
            this.vel.y *= -1;// Reverse the y-velocity
        }
        if (this.y + this.r > height) {
            this.y = height - this.r * 1.01f;
            this.vel.y *= -1; // Reverse the y-velocity
        }
    }
    public boolean isCollided() {
        return this.collided;
    }
    public void setCollided(boolean collided) {
        this.collided = collided;
    }   
}

class Line {
    float x1, y1, x2, y2;
    Vec2 start, end;
    Line(float x1, float y1, float x2, float y2) {
        this.x1 = x1; this.y1 = y1;
        this.x2 = x2; this.y2 = y2;
        this.start = new Vec2(x1, y1);
        this.end = new Vec2(x2, y2);
    }
    public void render() {
        push();
        stroke(255);
        line(this.x1, this.y1, this.x2, this.y2);
        pop();
    }
}

class Box {
    float x, y, w, h;
    Vec2 pos;
    Box(float x, float y, float w, float h) {
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.pos = new Vec2(x, y);
    }
    public void render() {
        push();
        stroke(255);
        fill(185, 214, 242);
        rect(this.x, this.y, this.w, this.h);
        pop();
    }
}
public class Vec2 {
  public float x, y;
  
  public Vec2(float x, float y){
    this.x = x;
    this.y = y;
  }
  
  public String toString(){
    return "(" + x+ "," + y +")";
  }
  
  public float length(){
    return sqrt(x*x+y*y);
  }
  
  public Vec2 plus(Vec2 rhs){
    return new Vec2(x+rhs.x, y+rhs.y);
  }
  
  public void add(Vec2 rhs){
    x += rhs.x;
    y += rhs.y;
  }
  
  public Vec2 minus(Vec2 rhs){
    return new Vec2(x-rhs.x, y-rhs.y);
  }
  
  public void subtract(Vec2 rhs){
    x -= rhs.x;
    y -= rhs.y;
  }
  
  public Vec2 times(float rhs){
    return new Vec2(x*rhs, y*rhs);
  }
  
  public void mul(float rhs){
    x *= rhs;
    y *= rhs;
  }
  
  public void clampToLength(float maxL){
    float magnitude = sqrt(x*x + y*y);
    if (magnitude > maxL){
      x *= maxL/magnitude;
      y *= maxL/magnitude;
    }
  }
  
  public void setToLength(float newL){
    float magnitude = sqrt(x*x + y*y);
    x *= newL/magnitude;
    y *= newL/magnitude;
  }
  
  public void normalize(){
    float magnitude = sqrt(x*x + y*y);
    x /= magnitude;
    y /= magnitude;
  }
  
  public Vec2 normalized(){
    float magnitude = sqrt(x*x + y*y);
    return new Vec2(x/magnitude, y/magnitude);
  }
  
  public float distanceTo(Vec2 rhs){
    float dx = rhs.x - x;
    float dy = rhs.y - y;
    return sqrt(dx*dx + dy*dy);
  }
}

public Vec2 interpolate(Vec2 a, Vec2 b, float t){
  return a.plus((b.minus(a)).times(t));
}

public float interpolate(float a, float b, float t){
  return a + ((b-a)*t);
}

public float dot(Vec2 a, Vec2 b){
  return a.x*b.x + a.y*b.y;
}

public Vec2 projAB(Vec2 a, Vec2 b){
  return b.times(a.x*b.x + a.y*b.y);
}


  public void settings() { size(550, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "old" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
