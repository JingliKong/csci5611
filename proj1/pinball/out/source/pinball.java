/* autogenerated by Processing revision 1293 on 2023-09-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.lang.Math;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class pinball extends PApplet {

public void updatePhysics(float dt) {
    for (int i = 0; i < numBalls; i++) {
        vel[i].add(acc[i].times(dt));
        pos[i].add(vel[i].times(dt));
        // Ball-Wall Collision (account for radius)
        if (pos[i].x < radius[i]) {
            pos[i].x = radius[i];
            vel[i].x *= -cor;
        }
        
        if (pos[i].x > width - radius[i]) {
            pos[i].x = width - radius[i];
            vel[i].x *= -cor;
        }
        if (pos[i].y < radius[i]) {
            pos[i].y = radius[i];
            vel[i].y *= -cor;
        }
        if (pos[i].y > height - radius[i]) {
            pos[i].y = height - radius[i];
            vel[i].y *= -cor;
        }
        // Ball-Ball Collision
        for (int j = i + 1; j < numBalls; j++) {
            Vec2 delta = pos[i].minus(pos[j]);
            float dist = delta.length();
            if (dist < radius[i] + radius[j]) { // checks ball to ball collisions 
                float overlap = 0.5f * (dist - radius[i] - radius[j]);
                pos[i].subtract(delta.normalized().times(overlap));
                pos[j].add(delta.normalized().times(overlap));
                // Collision
                Vec2 dir = delta.normalized();
                float v1 = dot(vel[i], dir);
                float v2 = dot(vel[j], dir);
                float m1 = mass[i];
                float m2 = mass[j];
                // Pseudo-code for collision response
                
                float new_v1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * cor) / (m1 + m2);
                float new_v2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * cor) / (m1 + m2);
                vel[i] = vel[i].plus(dir.times(new_v1 - v1)); // Add the change in velocity along the collision axis
                vel[j] = vel[j].plus(dir.times(new_v2 - v2)); //  ... collisions only affect velocity along this axis!
                
            }
        }
        // ball to line collisions 
        for (int j = 0; j < numLines; j++) {
            if (lineVsCircle(linePos[j], linePos[j+1], pos[i], radius[i])) {
                println(linePos[j]);
                println(linePos[j+1]);
                println("hit");
            }
        }
    }

}



// reset the balls to random positions and velocities
public void resetBalls() {
    for (int i = 0; i < numBalls; i++) {
        pos[i] = new Vec2(random(width), 0);
        vel[i] = new Vec2(random( -500, 500), random( -500, 500));
        acc[i] = new Vec2(0, 100);
        radius[i] = random(5, 40);
        mass[i] = radius[i] * radius[i]; //TODO: Change this to be proportional to area
    }
}

public void setup() {
    /* size commented out by preprocessor */;
    /* smooth commented out by preprocessor */;
    noStroke();
    // create the balls 
    resetBalls();
    
    // adding line locations
    linePos[0] = new Vec2(0, 540); 
    linePos[1] = new Vec2(0, 580);
    linePos[2] = new Vec2(0, 580);
    linePos[3] = new Vec2(150, 600);    


    // creating the flippers on opposite sides of the screen
    float radius = 5; 
    float length = 10;
    float maxRotation = 1.0f; 
    float restAngle = 0.5f;
    float angleVel = 10.0f; 
    float restitution = 0.0f; 

    Vec2 pos1 = new Vec2(26, 22);
    Vec2 pos2 = new Vec2(74, 22);

    
    
    // creating the circle obstacles
    circleObstacles[0] = new CircleObstacle(new Vec2(250, 250), 50, 20);
    circleObstacles[1] = new CircleObstacle(new Vec2(250, 450), 50, 20);
    circleObstacles[2] = new CircleObstacle(new Vec2(250, 650), 50, 20);

    // initializing the positions of the paddles 
    
}

public void draw() {
    // handles all the collisions between balls and the other obstacles
    updatePhysics(1 / frameRate);
    background(255);
    
    // drawing the slopes in to the paddle area
    stroke(0);
    strokeWeight(5);
    for (int i = 0; i < numLines*2; i +=2) {
        line(linePos[i].x, linePos[i].y, linePos[i+1].x, linePos[i+1].y);
    } 
    push();
    fill(41);
    noStroke();
    //draw the balls
    for (int i = 0; i < numBalls; i++) {
        circle(pos[i].x, pos[i].y, radius[i] * 2);
    }
    pop();
    // draw the flippers 

    // draw left flipper
    drawFlipper(leftFlipperX, flipperY, leftFlipperAngle);    
    // draw right flipper
    drawFlipper(rightFlipperX, flipperY, -rightFlipperAngle);

    // draw the circle obstacles 
    for (int i = 0; i < numCircleObstacles; i++) {
        push();
        fill(255, 0, 0); 
        circle(circleObstacles[i].pos.x, circleObstacles[i].pos.y, circleObstacles[i].radius * 2);
        pop();
    }
    text("Mouse X: " + mouseX + ", Mouse Y: " + mouseY, 10, 20);
    // handling key presses for paddles 
    // if we have its own function the paddle stays in the location it was moved 
    // so its easier just to put it here
    if (keyPressed) {
        if (key == CODED) {
        if (keyCode == LEFT && leftFlipperAngle < maxAngle) {
            leftFlipperAngle += angleSpeed;
        }
        if (keyCode == RIGHT && rightFlipperAngle < maxAngle) {
            rightFlipperAngle += angleSpeed;
        }
        }
    } else {
        // reset flipper angles when keys are not pressed
        leftFlipperAngle = 0;
        rightFlipperAngle = 0;
    }
    
    
}

public void keyPressed() {
    if(key == 'r' || key == 'R') {
        resetBalls();
}
}
public void handleFlipperBallCollisions() {
    // first find the closest point from the ball to the flipper
    Vec2 dir;
}
public boolean lineVsCircle(Vec2 lineStart, Vec2 lineEnd, Vec2 circleCenter, float circleRadius) {
    float max_t = 99999999;
    
    // direction of ray 
    Vec2 l_dir = lineEnd.minus(lineStart);
    // normalized dir 
    Vec2 l_dir_norm = l_dir.normalized();
    // length of line 
    float l_len = l_dir.length();
    // compute displacement orom ray start to circle center
    Vec2 toCircle = circleCenter.minus(lineStart);  
    //Step 3: Solve quadratic equation for intersection point (in terms of l_dir and toCircle)
    float a = 1; // we normalized l_dir 
    float b = -2 * dot(l_dir_norm, toCircle);
    float c = toCircle.lengthSqr() - circleRadius * circleRadius;
    float d = b * b - 4 * a * c; 
    if (d >= 0) {
        // If d is positive we know the line is colliding, but we need to check if the collision line within the line segment
        // ... this means t will be between 0 and the length of the line segment
        float t1 = (-b - sqrt(d)) / (2 * a);
        float t2 = (-b + sqrt(d)) / (2 * a);
        if ((t1 > 0 && t1 < l_len && t1 < max_t) || (t2 > 0 && t2 < l_len && t2 < max_t)) {
            return true;
        }
    }
    return false;
}
 

int numBalls = 10;
float cor = 0.95f; // Coefficient of Restitution
float obstacleSpeed = 150;


Vec2 pos[] = new Vec2[numBalls];
Vec2 vel[] = new Vec2[numBalls];
Vec2 acc[] = new Vec2[numBalls];
float radius[] = new float[numBalls];
float mass[] = new float[numBalls];

int numLines = 2; 
Vec2 linePos[] = new Vec2[numLines * 2];

// Flipper variables
float flipperLength = 100; // the length of the flipper
float flipperWidth = 20; // the width of the flipper
float leftFlipperX = 350; // x position of the left flipper
float rightFlipperX = 150; // x position of the right flipper
float flipperY = 600; // y position of the flippers
float maxAngle = PI/2; // maximum angle of rotation
float angleSpeed = 0.1f; // speed of rotation
float leftFlipperAngle = 0; // initial angle of the left flipper
float rightFlipperAngle = 0; // initial angle of the right flipper



// Circle obstacles 
int numCircleObstacles = 3;
CircleObstacle circleObstacles[] = new CircleObstacle[numCircleObstacles];
// float flipperLength = 100; // the length of the flipper
// float flipperWidth = 20; // the width of the flipper
// float leftFlipperX = 100; // x position of the left flipper
// float rightFlipperX = 300; // x position of the right flipper
// float flipperY = 350; // y position of the flippers
// float maxAngle = PI/2; // maximum angle of rotation
// float angleSpeed = 0.50; // speed of rotation

// float leftFlipperAngle = 0; // initial angle of the left flipper
// float rightFlipperAngle = 0; // initial angle of the right flipper

// void setup() {
//   size(400, 500);
// }

// void draw() {
//   background(200);
  
//   // draw left flipper
//   drawFlipper(leftFlipperX, flipperY, leftFlipperAngle);
  
//   // draw right flipper
//   drawFlipper(rightFlipperX, flipperY, -rightFlipperAngle);
  
//   // update flipper angles based on arrow keys
//   if (keyPressed) {
//     if (key == CODED) {
//       if (keyCode == LEFT && leftFlipperAngle < maxAngle) {
//         leftFlipperAngle += angleSpeed;
//       }
//       if (keyCode == RIGHT && rightFlipperAngle < maxAngle) {
//         rightFlipperAngle += angleSpeed;
//       }
//     }
//   } else {
//     // reset flipper angles when keys are not pressed
//     leftFlipperAngle = 0;
//     rightFlipperAngle = 0;
//   }
// }

// void drawFlipper(float x, float y, float angle) {
//   //noStroke();
//   pushMatrix();
//   translate(x, y);
//   rotate(angle);
//   rect(-flipperWidth/2, -flipperLength/2, flipperWidth, flipperLength);
//   arc(0, -flipperLength/2, flipperWidth, flipperWidth, PI, TWO_PI);
//   arc(0, flipperLength/2, flipperWidth, flipperWidth, 0, PI);
//   popMatrix();
// }


class CircleObstacle {
    Vec2 pos; 
    float radius;
    float bounceVel;
    CircleObstacle(Vec2 pos, float radius, float bounceVel) {
        this.radius = radius;
        this.pos = pos.clone();
        this.bounceVel = bounceVel;
        }
}

public void drawFlipper(float x, float y, float angle) {
    float endPointX = 0; 
    float endPointY = 0;
    pushMatrix();
    //Translate to the pivot point (the end of the flipper)
    float pivotX = x;
    float pivotY = y - flipperLength / 2;
    translate(pivotX, pivotY);
    rotate(angle);
    //Draw the rectangle representing the flipper
    rect( -flipperWidth / 2, 0, flipperWidth, flipperLength);
    //Draw arcs at the ends of the flipper
    //recall its x, y, width, height, start deg, end deg
    arc(0, 0, flipperWidth, flipperWidth, PI, TWO_PI); // Upper end
    arc(0, flipperLength, flipperWidth, flipperWidth, 0, PI); // Lower end
    endPointX = pivotX + flipperLength * sin(angle);
    endPointY = pivotY + flipperLength * cos(angle);
    // println("endPointX: " + endPointX);
    // println("endPointY: " + endPointY);
    circle(endPointX, -endPointY, 50);
    popMatrix(); 
    // println("endPointY: " + (-endPointY));
    // circle(endPointX, -endPointY, 50);
}


// class Flipper {
//     //fixed properties
//     float radius;
//     Vec2 pos; 
//     float length;
//     float restAngle;
//     float maxRotation;
//     int sign;
//     float angularVelocity;

//     //these get updated during the simulation  
//     float rotation;
//     float currentAngularVelocity;
//     int touchIdentifier;

//     //Constructor
//     Flipper(float radius, Vec2 pos, float length, float restAngle, float maxRotation, float angularVelocity, float restitution) {
//         this.radius = radius;
//         this.pos = pos.clone();
//         this.length = length;
//         this.restAngle = restAngle;
//         this.maxRotation = abs(maxRotation);
//         this.sign = (int) Math.signum(maxRotation);
//         this.angularVelocity = angularVelocity;

//         // initializing changing properties
//         this.rotation = 0.0;
//         this.currentAngularVelocity = 0.0;
//         this.touchIdentifier = -1;
// 	}
//     void simulate(float dt) {
//         float prevRotation = this.rotation;
//         boolean pressed = this.touchIdentifier >= 0;

//         if (pressed) {
//             this.rotation = min(this.rotation + dt * this.angularVelocity, this.maxRotation);
//         } else {
//             this.rotation = max(this.rotation - dt * this.angularVelocity, 0.0);
//         }

//         this.currentAngularVelocity = this.sign * (this.rotation - prevRotation) / dt;
//     }

//     boolean select(Vec2 pos) {
//         Vec2 d = this.pos.minus(pos);
//         return d.length() < this.length;
//     }

//     Vec2 getTip() {
//         float angle = this.restAngle + this.sign * this.rotation;
//         Vec2 dir = new Vec2(cos(angle), sin(angle));
//         Vec2 tip = this.pos.clone();
//         return tip.plus(dir.times(this.length));
//     }
	
// 	void drawFlipper(float x, float y, float angle) {
// 		pushMatrix();
// 		translate(x, y);
// 		rotate(angle);
// 		rect(-flipperWidth/2, -flipperLength/2, flipperWidth, flipperLength);
// 		arc(0, -flipperLength/2, flipperWidth, flipperWidth, PI, TWO_PI);
// 		arc(0, flipperLength/2, flipperWidth, flipperWidth, 0, PI);
// 		popMatrix();
// 	}
// }

// class Paddle {
//     float x, y, w, h;

//     Paddle(float x, float y, float w, float h) {
//         this.x = x;
//         this.y = y;
//         this.w = w;
//         this.h = h;
// }

//     void display() {
//         rect(x, y, w, h);
// }

//     void update() {
//         x = mouseX - w / 2;
// }
// }
public class Vec2 {
  public float x, y;
  
  public Vec2(float x, float y){
    this.x = x;
    this.y = y;
  }
  
  public Vec2 clone() {
	return new Vec2(this.x, this.y);
  }
  public String toString(){
    return "(" + x+ "," + y +")";
  }
  
  public float length(){
    return sqrt(x*x+y*y);
  }
  public float lengthSqr(){
    return x*x+y*y;
  }
  public Vec2 plus(Vec2 rhs){
    return new Vec2(x+rhs.x, y+rhs.y);
  }
  
  public void add(Vec2 rhs){
    x += rhs.x;
    y += rhs.y;
  }
  
  public Vec2 minus(Vec2 rhs){
    return new Vec2(x-rhs.x, y-rhs.y);
  }
  
  public void subtract(Vec2 rhs){
    x -= rhs.x;
    y -= rhs.y;
  }
  
  public Vec2 times(float rhs){
    return new Vec2(x*rhs, y*rhs);
  }
  
  public void mul(float rhs){
    x *= rhs;
    y *= rhs;
  }
  
  public void clampToLength(float maxL){
    float magnitude = sqrt(x*x + y*y);
    if (magnitude > maxL){
      x *= maxL/magnitude;
      y *= maxL/magnitude;
    }
  }
  
  public void setToLength(float newL){
    float magnitude = sqrt(x*x + y*y);
    x *= newL/magnitude;
    y *= newL/magnitude;
  }
  
  public void normalize(){
    float magnitude = sqrt(x*x + y*y);
    x /= magnitude;
    y /= magnitude;
  }
  
  public Vec2 normalized(){
    float magnitude = sqrt(x*x + y*y);
    return new Vec2(x/magnitude, y/magnitude);
  }
  
  public float distanceTo(Vec2 rhs){
    float dx = rhs.x - x;
    float dy = rhs.y - y;
    return sqrt(dx*dx + dy*dy);
  }
  public Vec2 perp() { // returns a vector rotated 90 degrees counter-clockwise
    return new Vec2(-this.y, this.x); 
  }
}

public Vec2 interpolate(Vec2 a, Vec2 b, float t){
  return a.plus((b.minus(a)).times(t));
}

public float interpolate(float a, float b, float t){
  return a + ((b-a)*t);
}

public float dot(Vec2 a, Vec2 b){
  return a.x*b.x + a.y*b.y;
}

public Vec2 projAB(Vec2 a, Vec2 b){
  return b.times(a.x*b.x + a.y*b.y);
}

public Vec2 closestPointOnSegment(Vec2 p, Vec2 a, Vec2 b) {
	Vec2 ab = b.minus(a);
	float t = dot(ab, ab);
  // if a and b are the same point
	if (t == 0) return a.clone();
	t = clamp((dot(p, ab) - dot(a, ab)) / t, 0.0f, 1.0f); 
  Vec2 closest = a.clone();
  return closest.plus (ab.times(t));
}

public float clamp(float val, float min_, float max_) {
	return max(min_, min(val, max_));
}


  public void settings() { size(500, 700);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "pinball" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
